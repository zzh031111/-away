# index.py (原web_api.py)
import json
import os
import sys  # 添加这行
import logging
import traceback
import time
import hmac
import hashlib
from datetime import datetime, timedelta
# 使用 Werkzeug 进行密码哈希，需要安装: pip install Werkzeug
from werkzeug.security import generate_password_hash, check_password_hash
# 使用 PyJWT 进行 Token 生成和验证，需要安装: pip install PyJWT
# import jwt
from flask import Flask, request, jsonify, send_from_directory
from qcloud_cos import CosConfig, CosS3Client
from flask_cors import CORS  # 导入CORS
import requests
import random
import re

# 导入腾讯云SDK相关模块
from tencentcloud.common import credential
from tencentcloud.common.profile.client_profile import ClientProfile
from tencentcloud.common.profile.http_profile import HttpProfile
from tencentcloud.common.exception.tencent_cloud_sdk_exception import TencentCloudSDKException
from tencentcloud.scf.v20180416 import scf_client, models as scf_models

# 在文件开头导入支付工具
# from payments_utils.payment_utils import PaymentConfig, PaymentService, generate_order_id

# 配置API基础URL
API_BASE_URL = os.environ.get('API_BASE_URL', 'https://1337331310-2gg2yrldrk.ap-beijing.tencentscf.com')

# 配置日志
logger = logging.getLogger('web_api')
logger.setLevel(logging.INFO)

# 添加日志处理器，确保日志被正确输出
handler = logging.StreamHandler()
handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
if not logger.handlers:  # 防止多次添加handler
    logger.addHandler(handler)

# JWT 配置暂时注释掉
# JWT_SECRET = os.environ.get('JWT_SECRET', 'YOUR_VERY_STRONG_SECRET_KEY_CHANGE_ME')
# JWT_ALGORITHM = 'HS256'
# JWT_EXPIRATION_DELTA = timedelta(days=7) # Token 有效期

# 支付配置 (示例，需要替换为您选择的支付提供商信息)
PAYMENT_PROVIDER_API_KEY = os.environ.get('PAYMENT_PROVIDER_API_KEY', 'YOUR_PAYMENT_API_KEY')
PAYMENT_PROVIDER_SECRET = os.environ.get('PAYMENT_PROVIDER_SECRET', 'YOUR_PAYMENT_SECRET')

# 在程序开始时安全地获取环境变量，避免访问不存在的变量
def get_env(name, default=''):
    """安全获取环境变量"""
    return os.environ.get(name, default)

# 使用该函数替代直接的环境变量访问
PAYMENT_RETURN_URL = get_env('PAYMENT_RETURN_URL', 'https://ai.kaxsx.top')
PAYMENT_NOTIFY_URL = get_env('PAYMENT_NOTIFY_URL', '')
PAYMENT_PID = get_env('PAYMENT_PID', '')
PAYMENT_KEY = get_env('PAYMENT_KEY', '')

# 定义支付相关的类和函数 - 移到这里，在使用前定义
def generate_order_id():
    """生成订单号"""
    return f"WX{int(time.time())}{str(int(time.time()*1000))[-3:]}"

class PaymentConfig:
    """支付配置"""
    def __init__(self):
        self.API_URL = 'https://z-pay.cn/submit.php'
        self.QUERY_URL = 'https://z-pay.cn/api.php'
        self.PID = ''  # 您的商户ID
        self.KEY = ''  # 您的商户密钥
        self.NOTIFY_URL = ''  # 异步通知地址
        self.RETURN_URL = ''  # 同步跳转地址

    def load_from_env(self):
        """从环境变量加载配置"""
        self.PID = os.environ.get('PAYMENT_PID', '')
        self.KEY = os.environ.get('PAYMENT_KEY', '')
        self.NOTIFY_URL = os.environ.get('PAYMENT_NOTIFY_URL', '')
        self.RETURN_URL = os.environ.get('PAYMENT_RETURN_URL', '')
        
        # 验证必要配置
        if not all([self.PID, self.KEY, self.NOTIFY_URL]):
            logger.warning("支付配置不完整，请检查环境变量 - PID, KEY, NOTIFY_URL")
            # 不抛出异常，只记录警告，以免阻止其他功能运行

class PaymentService:
    """支付服务"""
    def __init__(self, config: PaymentConfig):
        self.config = config

    def create_order(self, amount, order_id, product_name="微信推送服务", pay_type="alipay"):
        """创建支付订单"""
        try:
            # 构建签名参数
            params = {
                'pid': self.config.PID,
                'money': str(amount),
                'name': product_name,
                'out_trade_no': order_id,
                'notify_url': self.config.NOTIFY_URL,
                'return_url': self.config.RETURN_URL,
                'type': pay_type,
                'sitename': '微信推送服务'
            }

            # 生成签名
            sign_str = '&'.join(f"{k}={v}" for k, v in sorted(params.items()))
            sign = hashlib.md5((sign_str + self.config.KEY).encode('utf-8')).hexdigest()
            
            # 添加签名到参数
            params['sign'] = sign
            params['sign_type'] = 'MD5'

            # 生成完整的支付URL
            param_str = '&'.join(f"{k}={v}" for k, v in params.items())
            pay_url = f"{self.config.API_URL}?{param_str}"

            logger.info(f"生成支付订单成功: {order_id}")
            return {
                'success': True,
                'pay_url': pay_url,
                'order_id': order_id
            }

        except Exception as e:
            logger.error(f"创建支付订单失败: {str(e)}")
            return {
                'success': False,
                'message': f"创建支付订单失败: {str(e)}"
            }

    def query_order(self, order_id):
        """查询订单状态"""
        try:
            # 构建查询参数
            params = {
                'act': 'order',
                'pid': self.config.PID,
                'key': self.config.KEY,
                'out_trade_no': order_id
            }

            # 发送查询请求
            url = f"{self.config.QUERY_URL}?" + '&'.join(f"{k}={v}" for k, v in params.items())
            response = requests.get(url, timeout=10)
            result = response.json()

            logger.info(f"查询订单状态: {order_id}, 结果: {result}")
            
            if result.get('code') == 1:  # 成功
                return {
                    'success': True,
                    'paid': result.get('status') == 1,  # 1表示支付成功
                    'trade_no': result.get('trade_no', ''),
                    'message': '查询成功'
                }
            else:
                return {
                    'success': False,
                    'message': result.get('msg', '查询失败')
                }

        except Exception as e:
            logger.error(f"查询订单状态失败: {str(e)}")
            return {
                'success': False,
                'message': f"查询订单失败: {str(e)}"
            }

    def verify_notify(self, notify_data):
        """验证支付回调通知"""
        try:
            # 提取签名
            sign = notify_data.pop('sign', '')
            sign_type = notify_data.pop('sign_type', '')
            
            if not sign:
                return False
                
            # 生成签名字符串
            sign_str = '&'.join(f"{k}={v}" for k, v in sorted(notify_data.items()))
            local_sign = hashlib.md5((sign_str + self.config.KEY).encode('utf-8')).hexdigest()
            
            # 验证签名
            is_valid = sign.lower() == local_sign.lower()
            
            if is_valid:
                logger.info(f"支付回调验证成功: {notify_data.get('out_trade_no')}")
            else:
                logger.warning(f"支付回调验证失败: {notify_data.get('out_trade_no')}")
                
            return is_valid
            
        except Exception as e:
            logger.error(f"验证支付回调失败: {str(e)}")
            return False

# COS配置
def get_cos_client():
    config = CosConfig(
        Region=os.environ.get('COS_REGION', os.environ.get('REGION')),
        SecretId=os.environ.get('SECRETID'),
        SecretKey=os.environ.get('SECRETKEY')
    )
    return CosS3Client(config)

# SCF客户端配置
def get_scf_client():
    secret_id = os.environ.get('SECRETID')
    secret_key = os.environ.get('SECRETKEY')
    region = os.environ.get('REGION')
    
    if not all([secret_id, secret_key, region]):
        logger.error("缺少必要的腾讯云凭证或区域信息")
        raise ValueError("缺少腾讯云凭证或区域信息")
        
    cred = credential.Credential(secret_id, secret_key)
    httpProfile = HttpProfile()
    httpProfile.endpoint = "scf.tencentcloudapi.com"

    clientProfile = ClientProfile()
    clientProfile.httpProfile = httpProfile
    return scf_client.ScfClient(cred, region, clientProfile)

app = Flask(__name__)
CORS(app)  # 启用CORS，允许所有域名的请求

# 初始化支付配置 - 现在PaymentConfig已经被定义，可以正常使用
payment_config = PaymentConfig()
try:
    payment_config.load_from_env()
    payment_service = PaymentService(payment_config)
    logger.info("支付服务初始化成功")
except Exception as e:
    logger.error(f"支付服务初始化失败: {str(e)}")
    # 创建一个空的服务实例避免未定义错误
    payment_service = PaymentService(payment_config)

def create_response(body, status_code=200, callback=None):
    """创建标准响应格式，支持JSONP"""
    # 将JSON响应转换为字符串
    if not isinstance(body, str):
        body_str = json.dumps(body, ensure_ascii=False)
    else:
        body_str = body
    
    # 处理JSONP回调
    if callback:
        body_str = callback + "(" + body_str + ")"
        content_type = 'application/javascript'
    else:
        content_type = 'application/json'
    
    # 处理CORS头信息
    headers = {
        'Content-Type': content_type,
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization'
    }
    
    return {
        'isBase64Encoded': False,
        'statusCode': status_code,
        'headers': headers,
        'body': body_str
    }

def generate_success(data=None, message=None):
    """生成成功响应"""
    response = {'success': True}
    if data is not None:
        response['data'] = data
    if message is not None:
        response['message'] = message
    return create_response(response)

def generate_error(message, status_code=400):
    """生成错误响应"""
    return create_response({
        'success': False,
        'message': message
    }, status_code)

# 主页路由
@app.route('/', methods=['GET'])
def index():
    """提供配置页面"""
    logger.info("请求首页")
    return send_from_directory('.', 'frontend.html')

# 配置API
@app.route('/api/config', methods=['POST', 'OPTIONS'])
def save_config():
    """保存用户配置到COS"""
    logger.info(f"收到请求 - 方法: {request.method}, 路径: {request.path}")
    
    if request.method == 'OPTIONS':
        # 处理CORS预检请求
        return create_response('', 204)
    
    try:
        # 获取请求数据
        data = request.get_json()
        if not data:
            logger.error("无效的请求数据")
            return create_response({
                'success': False,
                'message': '无效的请求数据'
            }, 400)
        
        logger.info(f"收到配置数据: {json.dumps(data, ensure_ascii=False)}")
        
        # 验证必要参数
        required_fields = ['user_id', 'app_id', 'app_secret', 'template_id', 'user_openid']
        for field in required_fields:
            if not data.get(field):
                logger.error(f"缺少必要参数: {field}")
                return create_response({
                    'success': False,
                    'message': f'缺少必要参数: {field}'
                }, 400)
        
        # 设置默认值
        data.setdefault('location_name', '朝阳区')
        data.setdefault('adm_name', '北京市')
        data.setdefault('meet_date', '2025-02-04')
        data.setdefault('partner_birthday', '2000-02-22')
        data.setdefault('xiazhou_birthday', '2003-11-13')
        data.setdefault('indices_template_id', '')
        
        # 保存到COS
        client = get_cos_client()
        bucket = os.environ.get('COS_BUCKET')
        if not bucket:
            logger.error("环境变量COS_BUCKET未设置")
            return create_response({
                'success': False,
                'message': '服务器配置错误：存储桶未指定'
            }, 500)
        
        logger.info(f"使用存储桶: {bucket}")
        user_id = data['user_id']
        
        # 尝试在上传前检查存储桶是否存在
        try:
            client.head_bucket(Bucket=bucket)
            logger.info(f"存储桶 {bucket} 存在且可访问")
        except Exception as e:
            logger.error(f"存储桶 {bucket} 不存在或无法访问: {str(e)}")
            return create_response({
                'success': False,
                'message': f'存储配置失败：无法访问存储桶'
            }, 500)
        
        # 将配置转换为JSON格式
        config_json = json.dumps(data, ensure_ascii=False)
        
        # 上传到COS
        client.put_object(
            Bucket=bucket,
            Body=config_json.encode('utf-8'),
            Key=f'user_configs/{user_id}.json'
        )
        
        logger.info(f"成功上传配置到COS - User ID: {user_id}")
        
        return create_response({
            'success': True,
            'message': '配置保存成功'
        })
        
    except Exception as e:
        logger.error(f"处理API请求失败: {str(e)}", exc_info=True)
        return create_response({
            'success': False,
            'message': f'服务器错误: {str(e)}'
        }, 500)

# 测试发送API - 确保这个路由被正确添加到app中
@app.route('/api/test-send', methods=['POST', 'OPTIONS'])
def test_send():
    """测试发送微信消息"""
    logger.info(f"收到测试发送请求 - 方法: {request.method}, 路径: {request.path}")
    
    if request.method == 'OPTIONS':
        # 处理CORS预检请求
        return create_response('', 204)
    
    try:
        # 获取请求数据
        data = request.get_json()
        if not data:
            logger.error("无效的请求数据")
            return create_response({
                'success': False,
                'message': '无效的请求数据'
            }, 400)
            
        logger.info(f"收到测试数据: {json.dumps(data, ensure_ascii=False)}")
        
        # 验证必要参数
        required_fields = ['user_id', 'app_id', 'app_secret', 'template_id', 'user_openid']
        for field in required_fields:
            if not data.get(field):
                logger.error(f"缺少必要参数: {field}")
                return create_response({
                    'success': False,
                    'message': f'缺少必要参数: {field}'
                }, 400)
        
        # 设置默认值
        data.setdefault('location_name', '朝阳区')
        data.setdefault('adm_name', '北京市')
        data.setdefault('meet_date', '2025-02-04')
        data.setdefault('partner_birthday', '2000-02-22')
        data.setdefault('xiazhou_birthday', '2003-11-13')
        data.setdefault('indices_template_id', '')
        
        try:
            # 调用 morning_greeting 函数
            client = get_scf_client()
            function_name = os.environ.get('MORNING_GREETING_FUNCTION_NAME', 'morning-greeting')
            
            # 构造调用参数
            payload = {
                "source": "test-send",
                "config": data
            }
            
            logger.info(f"准备调用函数: {function_name}，Payload: {json.dumps(payload, ensure_ascii=False)}")
            
            req = scf_models.InvokeRequest()
            req.FunctionName = function_name
            req.Namespace = os.environ.get('SCF_NAMESPACE', 'default')
            req.InvocationType = "RequestResponse"  # 同步调用
            req.ClientContext = ""
            req.LogType = "Tail"
            req.Payload = json.dumps(payload, ensure_ascii=False)
            
            logger.info("开始调用云函数")
            resp = client.Invoke(req)
            logger.info(f"云函数调用响应: {resp}")
            
            # 处理函数返回结果
            result = resp.Result
            if result.RetMsg:
                try:
                    result_data = json.loads(result.RetMsg)
                    logger.info(f"函数返回结果: {result_data}")
                    return create_response(result_data)
                except json.JSONDecodeError:
                    logger.error(f"解析函数返回结果失败: {result.RetMsg}")
                    return create_response({
                        'success': False,
                        'message': '解析函数返回结果失败'
                    }, 500)
            else:
                logger.error(f"函数调用失败，错误码: {result.ErrCode}, 函数错误码: {result.FunctionErrorCode}")
                return create_response({
                    'success': False,
                    'message': f'函数调用失败，错误码: {result.ErrCode}, 函数错误码: {result.FunctionErrorCode}'
                }, 500)
                
        except TencentCloudSDKException as e:
            logger.error(f"调用云函数失败: {e}")
            return create_response({
                'success': False,
                'message': f'调用云函数失败: {str(e)}'
            }, 500)
            
    except Exception as e:
        logger.error(f"处理测试请求失败: {str(e)}", exc_info=True)
        return create_response({
            'success': False,
            'message': f'服务器错误: {str(e)}'
        }, 500)

# 添加新的API端点用于获取价格信息
def get_plan_prices():
    """获取当前的订阅计划价格，从环境变量读取"""
    try:
        prices = {
            'monthly': float(os.environ.get('PRICE_MONTHLY', '24.9')),
            'annual': float(os.environ.get('PRICE_ANNUAL', '29.9')),
            'permanent': float(os.environ.get('PRICE_PERMANENT', '99.9')),  # 可选的永久计划
            'update_time': datetime.now().strftime('%Y-%m-%d'),  # 价格更新时间
            'discount': os.environ.get('PRICE_DISCOUNT', '限时优惠')  # 可选的促销信息
        }
        # 使用与其他API端点相同的响应格式
        return create_response({
            'success': True,
            'data': prices
        })
    except Exception as e:
        logger.error(f"获取价格信息时出错: {str(e)}")
        return create_response({
            'success': False,
            'message': "获取价格信息失败"
        }, 400)

# 修改获取价格函数，从环境变量读取价格
def get_plan_price(plan):
    """从环境变量获取订阅计划的价格"""
    try:
        if plan == 'monthly':
            return float(os.environ.get('PRICE_MONTHLY', '24.90'))
        elif plan == 'annual':
            return float(os.environ.get('PRICE_ANNUAL', '59.90'))
        elif plan == 'permanent':
            return float(os.environ.get('PRICE_PERMANENT', '99.90'))
        else:
            return float(os.environ.get('PRICE_MONTHLY', '24.90'))  # 默认月度价格
    except (ValueError, TypeError):
        # 转换失败时使用默认值
        logger.warning(f"无法从环境变量读取{plan}价格，使用默认值")
        if plan == 'monthly':
            return 24.90
        elif plan == 'annual':
            return 59.90
        elif plan == 'permanent':
            return 99.90
        else:
            return 24.90

def create_payment_info(order_id, amount, plan):
    """创建支付信息，避免使用f-string包含反斜杠"""
    try:
        # 支付供应商API密钥
        payment_key = os.environ.get('PAYMENT_KEY', '')
        
        # 商品名称和描述
        product_name = "微信推送服务-" + plan
        
        # 定义基本参数（使用字典而不是f-string）
        params = {
            'pid': '2025032919123238',
            'money': str(amount),
            'name': product_name,
            'out_trade_no': order_id,
            'notify_url': f"{API_BASE_URL}/api/payment/webhook",
            'return_url': f"https://ai.kaxsx.top/?payment_success=true&order_id={order_id}",
            'type': 'alipay',
            'sitename': '微信推送服务'
        }
        
        # 生成签名 - 使用join而不是f-string
        sign_parts = []
        for k in sorted(params.keys()):
            sign_parts.append(k + "=" + params[k])
        sign_str = "&".join(sign_parts) + payment_key
        
        sign = hashlib.md5(sign_str.encode()).hexdigest()
        
        # 添加签名到参数
        params['sign'] = sign
        params['sign_type'] = 'MD5'
        
        # 构建支付URL - 使用join而不是f-string
        base_url = "https://z-pay.cn/submit.php"
        url_parts = []
        for k, v in params.items():
            url_parts.append(k + "=" + v)
        pay_url = base_url + "?" + "&".join(url_parts)
        
        # 生成表单HTML - 使用列表拼接而不是f-string
        html_parts = [
            "<html>",
            "<head><title>正在跳转到支付页面...</title></head>",
            "<body onload=\"document.getElementById('payform').submit();\">",
            "<form id=\"payform\" action=\"" + base_url + "\" method=\"post\">"
        ]
        
        for k, v in params.items():
            html_parts.append("<input type=\"hidden\" name=\"" + k + "\" value=\"" + v + "\" />")
        
        html_parts.append("</form>")
        html_parts.append("<p>正在跳转到支付页面，请稍候...</p>")
        html_parts.append("</body>")
        html_parts.append("</html>")
        
        form_html = "\n".join(html_parts)
        
        # 返回所有支付相关信息
        return {
            'payment_url': pay_url,
            'form_html': form_html,
            'qrcode_url': "https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=" + pay_url
        }
    except Exception as e:
        logger.error("创建支付信息失败: " + str(e), exc_info=True)
        raise

# 添加新的环境变量获取
PRICE_DUAL = float(os.environ.get('PRICE_DUAL', '52'))

# 修改价格信息API，增加双人套餐价格
@app.route('/api/price', methods=['GET'])
def get_price():
    price_info = {
        'monthly': 1,
        'annual': 3,
        'dual': 2
    }
    return create_response(price_info)

# 修改配置更新API，不再检查用户登录状态
@app.route('/api/config/update', methods=['POST'])
def update_config():
    try:
        body = request.get_json()
        
        # 获取配置信息
        phone = body.get('phone', '')  # 作为 user_id 使用
        config = body.get('config', {})
        
        if not phone:
            return create_response({
                'success': False,
                'message': '缺少必要信息'
            }, 400)
            
        # 不再验证用户身份，直接保存配置
        client = get_cos_client()
        config_file_key = f"user_configs/{phone}.json"
        
        client.put_object(
            Bucket=os.environ.get('COS_BUCKET'),
            Key=config_file_key,
            Body=json.dumps(config, ensure_ascii=False)
        )
        
        return create_response({
            'success': True,
            'message': '配置保存成功'
        })
    except Exception as e:
        logger.error(f"更新配置失败: {str(e)}", exc_info=True)
        return create_response({
            'success': False,
            'message': f'更新配置失败: {str(e)}'
        }, 500)

# 处理SCF请求的入口函数
def main_handler(event, context):
    """
    主处理函数，处理所有API请求
    """
    # 记录收到的事件和环境变量
    logger.info(f"收到事件: {json.dumps(event, ensure_ascii=False)}")
    
    # 提取路径和HTTP方法
    path = event.get('path', '')
    http_method = event.get('httpMethod', '')
    
    logger.info(f"收到请求: 路径={path}, 方法={http_method}")
    
    # 处理OPTIONS预检请求
    if http_method == 'OPTIONS':
        return {
            'isBase64Encoded': False,
            'statusCode': 204,
            'headers': {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type, Authorization',
                'Access-Control-Max-Age': '86400'
            },
            'body': ''
        }
    
    # 处理价格API请求 - 单独实现，添加JSONP支持
    elif path == '/api/price' and http_method == 'GET':
        try:
            # 获取查询参数
            query_params = event.get('queryString', {})
            callback = query_params.get('callback', None)
            
            # 从环境变量获取价格
            price_info = {
                'monthly': 1,
                'annual': 3,
                'dual': 2
            }
            
            # 如果有callback参数，返回JSONP格式
            if callback:
                response_body = f"{callback}({json.dumps(price_info)})"
                return {
                    'isBase64Encoded': False,
                    'statusCode': 200,
                    'headers': {
                        'Content-Type': 'application/javascript',
                        'Access-Control-Allow-Origin': '*'
                    },
                    'body': response_body
                }
            else:
                # 否则返回普通JSON
                return create_response(price_info)
                
        except Exception as e:
            logger.error(f"获取价格信息失败: {str(e)}", exc_info=True)
            return create_response({
                'success': False,
                'message': f'获取价格信息失败: {str(e)}'
            }, 500)
    
    # 处理支付创建请求
    elif path == '/api/payment/create' and http_method == 'POST':
        try:
            # 直接从事件中解析JSON数据
            body = json.loads(event.get('body', '{}'))
            phone = body.get('phone')
            plan = body.get('plan', 'monthly')
            
            # 价格查询
            prices = {
                'monthly': 1,
                'annual': 3,
                'dual': 2
            }
            
            price = prices.get(plan, 24.9)
            
            # 创建订单号
            order_id = f"WX{int(time.time())}"
            
            # 获取商户信息
            pid = os.environ.get('ZPAY_PID', '2025032919123238')
            key = os.environ.get('ZPAY_KEY', '')  # 商户密钥
            
            # 准备支付参数 - 确保所有值都是字符串
            payment_data = {
                'pid': pid,
                'money': str(price),
                'name': f'微信推送服务-{plan}',
                'out_trade_no': order_id,
                'notify_url': f"{API_BASE_URL}/api/payment/webhook",
                'return_url': f"https://ai.kaxsx.top/?payment_success=true&order_id={order_id}",
                'type': 'alipay',
                'sitename': '微信推送服务'
            }
            
            # 输出调试信息
            logger.info(f"API_BASE_URL: {API_BASE_URL}")
            
            # 直接使用z-pay网站示例代码改编的签名生成
            def create_sign(params, key):
                """按照z-pay要求的方式生成签名"""
                # 1. 按字母升序排列所有请求参数
                params_str = ''
                for k in sorted(params.keys()):
                    params_str += f"{k}={params[k]}&"
                
                # 2. 去掉最后一个&符号
                params_str = params_str[:-1]
                
                # 3. 拼接商户密钥
                sign_str = params_str + key
                
                # 4. 计算MD5签名
                sign = hashlib.md5(sign_str.encode('utf-8')).hexdigest()
                
                return sign, sign_str

            # 生成签名
            sign, sign_str = create_sign(payment_data, key)
            
            # 添加签名到参数中
            payment_data['sign'] = sign
            payment_data['sign_type'] = 'MD5'
            
            # 使用urlencode正确编码参数
            from urllib.parse import urlencode, quote
            param_str = urlencode(payment_data)
            
            # 构建支付URL
            payment_url = f"https://z-pay.cn/submit.php?{param_str}"
            qrcode_url = f"https://api.qrserver.com/v1/create-qr-code/?size=200x200&data={quote(payment_url)}"
            
            logger.info(f"订单已创建: {order_id}, 金额: {price}, 类型: {plan}")
            logger.info(f"支付URL: {payment_url}")
            
            return create_response({
                'success': True,
                'order_id': order_id,
                'payment_url': payment_url,
                'qrcode_url': qrcode_url
            })
        except Exception as e:
            logger.error(f"创建支付订单失败: {str(e)}")
            return create_response({
                'success': False,
                'message': f"创建支付订单失败: {str(e)}"
            }, 500)
    
    # 在main_handler函数中添加/api/save-config路由处理
    elif path == '/api/save-config' and http_method == 'POST':
        try:
            # 解析请求数据
            body = json.loads(event.get('body', '{}'))
            phone = body.get('phone')
            plan = body.get('plan')
            order_id = body.get('order_id')
            config = body.get('config', {})
            
            logger.info(f"开始保存配置: 手机={phone}, 计划={plan}, 订单ID={order_id}")
            
            # 验证必要字段
            if not all([phone, plan, order_id, config]):
                logger.error("缺少必要的配置字段")
                return create_response({
                    'success': False,
                    'message': '缺少必要的配置字段'
                }, 400)
            
            # 准备共享配置项
            app_id = config.get('app_id', '')
            app_secret = config.get('app_secret', '')
            indices_template_id = config.get('indices_template_id', '')
            
            # 根据套餐类型设置过期时间
            if plan == 'monthly':
                expiry_days = 30
            elif plan == 'annual':
                expiry_days = 365
            elif plan == 'dual':
                expiry_days = 30
            else:
                expiry_days = 30
            
            start_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            end_date = (datetime.now() + timedelta(days=expiry_days)).strftime('%Y-%m-%d %H:%M:%S')
            
            # 获取COS客户端
            try:
                client = get_cos_client()
                
                # 如果是双人套餐，创建两个配置文件
                if plan == 'dual' and 'user_config' in config:
                    # 伴侣配置 - 主要用户
                    partner_config = {
                        'user_id': phone,
                        'created_at': start_date,
                        'updated_at': start_date,
                        'plan': plan,
                        'start_date': start_date,
                        'end_date': end_date,
                        'status': 'active',
                        'app_id': app_id,
                        'app_secret': app_secret,
                        'template_id': config.get('template_id', ''),
                        'indices_template_id': indices_template_id,
                        'user_openid': config.get('user_openid', ''),
                        'location_name': config.get('location_name', ''),
                        'adm_name': config.get('adm_name', ''),
                        'meet_date': config.get('meet_date', ''),
                        'partner_birthday': config.get('xiazhou_birthday', ''),  # 对调生日
                        'xiazhou_birthday': config.get('partner_birthday', '')   # 对调生日
                    }
                    
                    # 自己的配置 - 用户本人
                    user_config = config.get('user_config', {})
                    self_config = {
                        'user_id': phone + '_self',  # 用一个标记区分
                        'created_at': start_date,
                        'updated_at': start_date,
                        'plan': plan,
                        'start_date': start_date,
                        'end_date': end_date,
                        'status': 'active',
                        'app_id': app_id,
                        'app_secret': app_secret,
                        'template_id': user_config.get('template_id', ''),
                        'indices_template_id': indices_template_id,
                        'user_openid': user_config.get('user_openid', ''),
                        'location_name': user_config.get('location_name', ''),
                        'adm_name': user_config.get('adm_name', ''),
                        'meet_date': config.get('meet_date', ''),
                        'partner_birthday': config.get('partner_birthday', ''),  # 这里不对调
                        'xiazhou_birthday': config.get('xiazhou_birthday', '')   # 这里不对调
                    }
                    
                    # 存储伴侣配置
                    partner_config_key = f"user_configs/{phone}.json"
                    client.put_object(
                        Bucket=os.environ.get('COS_BUCKET', 'zaoan-1337331310'),
                        Key=partner_config_key,
                        Body=json.dumps(partner_config, ensure_ascii=False)
                    )
                    
                    # 存储自己的配置
                    self_config_key = f"user_configs/{phone}_self.json"
                    client.put_object(
                        Bucket=os.environ.get('COS_BUCKET', 'zaoan-1337331310'),
                        Key=self_config_key,
                        Body=json.dumps(self_config, ensure_ascii=False)
                    )
                    
                    logger.info(f"双人套餐配置已保存: {partner_config_key} 和 {self_config_key}")
                else:
                    # 单人套餐，只创建一个配置文件
                    user_config = {
                        'user_id': phone,
                        'created_at': start_date,
                        'updated_at': start_date,
                        'plan': plan,
                        'start_date': start_date,
                        'end_date': end_date,
                        'status': 'active',
                        'app_id': app_id,
                        'app_secret': app_secret,
                        'template_id': config.get('template_id', ''),
                        'indices_template_id': indices_template_id,
                        'user_openid': config.get('user_openid', ''),
                        'location_name': config.get('location_name', ''),
                        'adm_name': config.get('adm_name', ''),
                        'meet_date': config.get('meet_date', ''),
                        'partner_birthday': config.get('partner_birthday', ''),
                        'xiazhou_birthday': config.get('xiazhou_birthday', '')
                    }
                    
                    # 存储配置
                    config_key = f"user_configs/{phone}.json"
                    client.put_object(
                        Bucket=os.environ.get('COS_BUCKET', 'zaoan-1337331310'),
                        Key=config_key,
                        Body=json.dumps(user_config, ensure_ascii=False)
                    )
                    
                    logger.info(f"单人套餐配置已保存: {config_key}")
                
                # 创建用户索引文件，便于查询
                index_filename = f"indices/phone_{phone}.json"
                index_data = {
                    'phone': phone,
                    'latest_order': order_id,
                    'latest_plan': plan,
                    'config_file': f"user_configs/{phone}.json",
                    'updated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                }
                
                client.put_object(
                    Bucket=os.environ.get('COS_BUCKET', 'zaoan-1337331310'),
                    Key=index_filename,
                    Body=json.dumps(index_data, ensure_ascii=False)
                )
                
                return create_response({
                    'success': True,
                    'message': '配置保存成功',
                    'data': {
                        'end_date': end_date
                    }
                })
                
            except Exception as e:
                logger.error(f"保存配置到COS失败: {str(e)}")
                return create_response({
                    'success': False,
                    'message': f'保存配置失败: {str(e)}'
                }, 500)
            
        except Exception as e:
            logger.error(f"处理保存配置请求失败: {str(e)}")
            return create_response({
                'success': False,
                'message': f'服务器错误: {str(e)}'
            }, 500)
    
    # 处理其他API请求...
    # 此处省略其他路由处理...
    
    else:
        return create_response({
            'success': False,
            'message': '请求的资源不存在'
        }, 404)

def handle_get_payment_status(event):
    """处理查询支付状态请求"""
    try:
        order_id = event.get('pathParameters', {}).get('order_id')
        if not order_id:
            return create_response({
                'success': False,
                'message': '缺少订单号'
            }, 400)
            
        result = payment_service.query_order(order_id)
        return create_response(result)
        
    except Exception as e:
        logger.error(f"查询支付状态失败: {str(e)}", exc_info=True)
        return create_response({
            'success': False,
            'message': f'查询支付状态失败: {str(e)}'
        }, 500)

# 本地测试使用
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=9000) 
